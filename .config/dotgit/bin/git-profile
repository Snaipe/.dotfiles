#!/bin/sh -e

# always use the current work tree for our profiles
export GIT_WORK_TREE="$(git rev-parse --show-toplevel)"

# we perform dangerous operations on paths like $GIT_DIR/*, so we
# check that the variable isn't empty to prevent an unfortunate rm -Rf /.
if [ -z "$GIT_DIR" ]; then
    >&2 echo "GIT_DIR is not set; we cannot continue safely."
    exit 1
fi

if [ -f "$GIT_DIR"/commondir ]; then
    export GIT_DIR="$GIT_DIR/$(cat "$GIT_DIR/commondir")"
fi

export GIT_DIR="$(perl -MCwd -e 'print Cwd::realpath($ENV{GIT_DIR}),qq<\n>')"

if [ -z "$GIT_DIR" ]; then
    >&2 echo "GIT_DIR is not set; we cannot continue safely."
    exit 1
fi

usage() {
    echo <<EOF
usage: dot profile [<action>] [<options>] <profile-name> [...]
       dot profile add <profile-name> [<parent-profile>]
       dot profile list

global options:

    -h, --help          display this message

actions:

    list                list the available profiles. This runs when no argument
                        after "profile" is provided.

    select              run a git command against the specified profile.
                        This is the default action.

    switch              switch the selection to the specified profile.

    add                 create a profile, optionally based on an existing profile.

    rm                  removes a profile.
        -f, --force     don't ask for confirmation

    link                link an existing profile into the home directory
        -f, --force     overwrite any staging changes

    unlink              unlink an existing profile from the home directory
        -f, --force     overwrite any staging changes

EOF
    exit 0
}

if [ $# -eq 0 ]; then
    cmd="list"
else
    cmd="select"
    case "$1" in
        add|rm|select|link|unlink|list|switch) cmd="$1"; shift;;
    esac
fi

i=1
while [ $i -le $# ]; do
    eval "arg=\${$i}"
    case "$arg" in
        -h|--help) usage;;
        -f|--force) force=1;;
        --) shift; break;;
        -*) >&2 echo "dot: Unsupported option '$arg'."; exit 3;;
        *) break;;
    esac
    shift
    i=$((i+1))
done
unset i

case "$cmd" in
    list)
        if [ -d $GIT_DIR/worktrees ] && [ -x $GIT_DIR/worktrees ]; then
            cd $GIT_DIR/worktrees
            find . -mindepth 1 -maxdepth 1 -type d  \
               | grep -E '^./dot-'                  \
               | sed 's|^./dot-||'
        fi
        exit 0;
    ;;
esac

profile=$1; shift
if [ "$profile" = master ]; then
    workdir="$GIT_DIR"
    branch=master
else
    workdir="$GIT_DIR/worktrees/dot-$profile"
    branch="dot-$profile"
fi

case "$cmd" in
    add)
        if [ -d "$workdir" ]; then
            >&2 echo "dot: Profile '$profile' already exists."
            exit 3
        fi

        rev=HEAD
        if [ -n "$1" ]; then
            rev=dot-$1
        fi

        trap 'rm -rf "$tmpdir"' EXIT
        tmpdir=$(mktemp -d 2>/dev/null)

        # create a worktree and lock it
        git worktree add "$tmpdir"/dot-$profile HEAD >/dev/null
        rm "$workdir"/gitdir
        touch "$workdir"/locked
        echo "Creating new worktree based on imaginary branch dot-$profile."

        git --git-dir="$workdir" symbolic-ref HEAD refs/heads/dot-$profile
        if [ "$rev" = "HEAD" ]; then
            echo "HEAD is now orphaned."
            rm "$workdir"/index
            echo "Index has been reset to its empty state."
        else
            git branch dot-$profile $rev
            echo "Branch dot-$profile has been created from $rev."
        fi
    ;;
    rm)
        if [ "$profile" = master ]; then
            >&2 echo "dot: Cannot remove master profile."
            exit 1
        fi
        while [ -z "$force" ]; do
            read -p "Remove profile '$profile' and its associated branch? [y/N]: " yn
            case $yn in
                [Yy]*|yes) break;;
                *) exit 1;;
            esac
        done

        rm -rf "$workdir"
        git branch -D "dot-$profile" 2>/dev/null
        exit 0
    ;;
    select)
        if [ ! -d "$workdir" ]; then
            >&2 echo "dot: Unknown profile '$profile'."
            exit 3
        fi

        exec git --git-dir="$workdir" "$@"
    ;;
    switch)
        repo=$(echo $workdir | sed -e "s|^$GIT_DIR|.|")
        ln -snf $repo $GIT_DIR/repo
        echo "Switched to profile '$profile'."
    ;;
    link)
        if ! git rev-parse --quiet --verify $branch >/dev/null; then
            >&2 echo "dot: Unknown profile '$profile'."
            exit 3
        fi
        if [ -d "$workdir" ]; then
            >&2 echo "dot: Profile '$profile' is already linked."
            exit 3
        fi

        git --git-dir="$workdir" symbolic-ref HEAD refs/heads/$branch
        git --git-dir="$workdir" reset --hard HEAD
    ;;
    unlink)
        if [ "$profile" = master ]; then
            >&2 echo "dot: Cannot unlink master profile."
            exit 3
        fi
        if [ ! -d "$workdir" ]; then
            >&2 echo "dot: Unknown profile '$profile'."
            exit 3
        fi

        if [ -z "$force" ]; then
            read -p "Remove all files belonging to profile '$profile'? [y/N]: " yn
            case $yn in
                [Yy]*|yes);;
                *) exit 1;;
            esac
        fi

        git --git-dir="$workdir" ls-files -z | xargs -0 rm -f
        git --git-dir="$workdir" ls-tree --name-only -d -r -z HEAD \
            | sort -rz | xargs -0 rmdir
        rm -rf "$workdir"
    ;;
esac
